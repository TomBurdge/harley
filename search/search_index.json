{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Harley","text":"<p>Harley contains polars helper methods that will make you more productive.</p> <p>Checkout the full code documentation here.</p> <p>Harley is also a great way to learn about polars best practices, like how to use plugins for custom functionality at speed.</p> <p>Harley is a polars port of Harley's sister project, Quinn.  Many of Quinn's original methods, written to extend pyspark, are trivial with the excellent polars API.</p> <p>Harley is neither associated with motorbikes, nor the DC universe.</p>"},{"location":"#getting-started","title":"Getting started","text":"<p>In addition to reading the docs, you can pip install harley with: <pre><code>python -m pip install harley\n</code></pre></p>"},{"location":"#contributing","title":"Contributing","text":"<p>Want to contribute to Harley? You are more than welcome!</p> <p>Anything that would improve your own polars development experience is a great candidate for a feature.</p> <p>If you wish to write some rust via a polars plugin with your feature, Marco Gorelli's tutorial is a perfect place to start.</p>"},{"location":"#code-style","title":"Code Style","text":"<p>We use <code>sphinx</code> as docstrings format. For more details about <code>sphinx</code> format see this tutorial. A short example of <code>sphinx</code>-formatted docstring is placed below:</p> <pre><code>\"\"\"[Summary]\n\n:param [ParamName]: [ParamDescription], defaults to [DefaultParamVal]\n:type [ParamName]: [ParamType](, optional)\n...\n:raises [ErrorType]: [ErrorDescription]\n...\n:return: [ReturnDescription]\n:rtype: [ReturnType]\n\"\"\"\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>harley<ul> <li>column_functions</li> <li>dataframe_helper</li> <li>dataframe_validator</li> <li>maths</li> <li>schema_helpers</li> <li>string_functions</li> <li>to_boolean</li> <li>transformations</li> </ul> </li> </ul>"},{"location":"reference/Summary/","title":"Summary","text":"<ul> <li>harley<ul> <li>column_functions</li> <li>dataframe_helper</li> <li>dataframe_validator</li> <li>maths</li> <li>schema_helpers</li> <li>string_functions</li> <li>to_boolean</li> <li>transformations</li> </ul> </li> </ul>"},{"location":"reference/harley/","title":"Index","text":""},{"location":"reference/harley/#harley.anti_trim","title":"<code>anti_trim(expr)</code>","text":"<p>Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def anti_trim(expr: List[IntoExpr]) -&gt; IntoExpr:\n    \"\"\"\n    Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"anti_trim\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/#harley.approx_equal","title":"<code>approx_equal(col_1, col_2, threshold)</code>","text":"<p>Compares two columns for approximate equality within a specified threshold.</p> <p>Parameters:</p> Name Type Description Default <code>col_1</code> <code>IntoExpr</code> <p>The first column or expression that you want to compare for approximate equality</p> required <code>col_2</code> <code>IntoExpr</code> <p>The second column or value that you want to compare for approximate equality with col_1</p> required <code>threshold</code> <code>Union[float, int]</code> <p>Specifies the  maximum allowable difference between the values in <code>col_1</code> and <code>col_2</code> for them to be considered approximately equal.</p> required <p>Returns:</p> Type Description <code>IntoExpr</code> <p>boolean typed expression.</p> Source code in <code>harley/column_functions.py</code> <pre><code>def approx_equal(\n    col_1: IntoExpr, col_2: IntoExpr, threshold: Union[float, int]\n) -&gt; IntoExpr:\n    \"\"\"\n    Compares two columns for approximate equality within a specified threshold.\n\n    :param col_1: The first column or expression that you want to compare for approximate\n    equality\n    :type col_1: IntoExpr\n    :param col_2: The second column or value that you want to\n    compare for approximate equality with col_1\n    :type col_2: IntoExpr\n    :param threshold: Specifies the  maximum allowable difference between the values in `col_1` and `col_2` for them to be considered\n    approximately equal.\n    :type threshold: Union[float, int]\n    :return: boolean typed expression.\n    \"\"\"\n    col_1 = parse_into_expr(col_1)\n    col_2 = parse_into_expr(col_2)\n    return register_plugin(\n        args=[col_1, col_2],\n        symbol=\"approx_equal\",\n        is_elementwise=True,\n        lib=lib,\n        kwargs={\"threshold\": float(threshold)},\n    )\n</code></pre>"},{"location":"reference/harley/#harley.column_to_list","title":"<code>column_to_list(df, column)</code>","text":"<p>Takes a PolarsFrame and a column name, extracts the specified column as a list, and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>PolarsFrame</p> required <code>column</code> <code>str</code> <p>The name of the column in the Polars DataFrame (<code>df</code>) that you want to extract and convert into a Python list</p> required <p>Returns:</p> Type Description <code>List</code> <p>a list of values from the specified column in the PolarsFrame dataframe.</p> Source code in <code>harley/dataframe_helper.py</code> <pre><code>def column_to_list(df: PolarsFrame, column: str) -&gt; List:\n    \"\"\"\n    Takes a PolarsFrame and a column name, extracts the specified column as a list, and\n    returns it.\n\n    :param df: PolarsFrame\n    :type df: PolarsFrame\n    :param column: The name of the column in\n    the Polars DataFrame (`df`) that you want to extract and convert into a Python list\n    :type column: str\n    :return: a list of values from the specified column in the PolarsFrame dataframe.\n    \"\"\"\n    if isinstance(df := df.select(column), LazyFrame):\n        df = df.collect()\n    series = df.select(column).to_series()\n    return series.to_list()\n</code></pre>"},{"location":"reference/harley/#harley.div_or_else","title":"<code>div_or_else(dividend, divisor, or_else=0.0)</code>","text":"<p>Returns the result of dividing one expression by another, with an optional default value if the divisor is zero.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>IntoExpr</code> <p>The value that will be divided</p> required <code>divisor</code> <code>IntoExpr</code> <p>The value by which the <code>dividend</code> will be divided. If the <code>divisor</code> is zero, the function will return the <code>or_else</code> value instead of performing the division</p> required <code>or_else</code> <code>Union[int, float]</code> <p>TA default value that will be returned if the divisor is zero. It is a numeric value (either an integer or a float) and is set to 0.0 by default if not provided explicitly.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>IntoExpr</code> <p>The result of the division of <code>dividend</code> by <code>divisor</code>, or the default value <code>or_else</code> if the divisor is zero.</p> Source code in <code>harley/maths.py</code> <pre><code>def div_or_else(\n    dividend: IntoExpr, divisor: IntoExpr, or_else: Union[int, float] = 0.0\n) -&gt; IntoExpr:\n    \"\"\"\n    Returns the result of dividing one expression by another, with an optional default\n    value if the divisor is zero.\n\n    :param dividend: The value that will be divided\n    :type dividend: IntoExpr\n    :param divisor: The value by which\n    the `dividend` will be divided. If the `divisor` is zero, the function will return the `or_else`\n    value instead of performing the division\n    :type divisor: IntoExpr\n    :param or_else: TA default value that will\n    be returned if the divisor is zero. It is a numeric value (either an integer or a float) and is set\n    to 0.0 by default if not provided explicitly.\n    :type or_else: Union[int, float]\n    :return: The result of the division of `dividend` by `divisor`,\n    or the default value `or_else` if the divisor is zero.\n    \"\"\"\n    dividend = parse_into_expr(dividend)\n    divisor = parse_into_expr(divisor)\n    return register_plugin(\n        args=[dividend, divisor],\n        symbol=\"div_or_else\",\n        is_elementwise=True,\n        kwargs={\"or_else\": float(or_else)},\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/#harley.flatten_struct","title":"<code>flatten_struct(df, struct_columns, separator=':', drop_original_struct=True, recursive=False, limit=None)</code>","text":"<p>Takes a PolarsFrame and flattens specified struct columns into separate columns using a specified separator, with options to control recursion and limit the number of flattening levels.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame, either a LazyFrame or DataFrame.</p> required <code>struct_columns</code> <code>Union[str, List[str]]</code> <p>The column or columns in the PolarsFrame that contain struct data. This function is designed to flatten the struct data into separate columns based on the fields within the struct.</p> required <code>separator</code> <code>str</code> <p>Specifies the character or string that will be used to separate the original column name from the nested field names when flattening a nested struct column.</p> <code>':'</code> <code>drop_original_struct</code> <code>bool</code> <p>Determines whether the original struct columns should be dropped after flattening or not, defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Determines whether the flattening process should be applied recursively to all levels of nested structures within the specified struct columns, defaults to False.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Determines the maximum number of levels to flatten the struct columns. If <code>limit</code> is set to a positive integer, the function will flatten the struct columns up to that specified level. If <code>limit</code> is set to <code>None</code>, there is no limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolarsFrame</code> <p>returns a PolarsFrame.</p> Source code in <code>harley/transformations.py</code> <pre><code>def flatten_struct(\n    df: PolarsFrame,\n    struct_columns: Union[str, List[str]],\n    separator: str = \":\",\n    drop_original_struct: bool = True,\n    recursive: bool = False,\n    limit: int = None,\n) -&gt; PolarsFrame:\n    \"\"\"\n    Takes a PolarsFrame and flattens specified struct columns into\n    separate columns using a specified separator,\n    with options to control recursion and limit the number\n    of flattening levels.\n\n    :param df: A PolarsFrame, either a LazyFrame or DataFrame.\n    :type df: PolarsFrame\n    :param struct_columns: The column or columns in the PolarsFrame that contain struct data.\n    This function is designed to flatten the struct data into separate columns based on the fields within the struct.\n    :type struct_columns: Union[str, List[str]]\n    :param separator: Specifies the character or string that will be used to separate the original\n    column name from the nested field names when flattening a nested struct column.\n    :type separator: str (optional)\n    :param drop_original_struct: Determines whether the original struct columns should be dropped after flattening or not,\n    defaults to True.\n    :type drop_original_struct: bool (optional)\n    :param recursive: Determines whether the flattening process should be applied recursively to\n    all levels of nested structures within the specified struct columns, defaults to False.\n    :type recursive: bool (optional)\n    :param limit: Determines the maximum number of levels to flatten the struct columns.\n    If `limit` is set to a positive integer, the function will flatten the struct columns up to that specified level.\n    If `limit` is set to `None`, there is no limit.\n    :type limit: int\n    :return: returns a PolarsFrame.\n    \"\"\"\n    if isinstance(struct_columns, str):\n        struct_columns = [struct_columns]\n    if not recursive:\n        limit = 1\n    if limit is not None and not isinstance(limit, int):\n        raise ValueError(\"limit must be a positive integer or None\")\n    if limit is not None and limit &lt; 0:\n        raise ValueError(\"limit must be a positive integer or None\")\n    if limit == 0:\n        warnings.warn(\"limit of 0 will result in no transformations\")\n        return df\n    ldf = df.lazy()  # noop if df is LazyFrame\n    all_column_names = ldf.collect_schema().names()\n    if any(separator in (witness := column) for column in all_column_names):\n        warnings.warn(\n            f'separator \"{separator}\" found in column names, e.g. \"{witness}\". '\n            \"If columns would be repeated, this function will error\"\n        )\n    non_struct_columns = list(set(ldf.collect_schema().names()) - set(struct_columns))\n    struct_schema = ldf.select(*struct_columns).collect_schema()\n    col_dtype_expr_names = [(struct_schema[c], col(c), c) for c in struct_columns]\n    result_names: Dict[str, Expr] = {}\n    level = 0\n    while (limit is None and col_dtype_expr_names) or (\n        limit is not None and level &lt; limit\n    ):\n        level += 1\n        new_col_dtype_exprs = []\n        for dtype, col_expr, name in col_dtype_expr_names:\n            if not isinstance(dtype, Struct):\n                if name in result_names:\n                    raise ColumnNameRepeatedError(\n                        f\"Column name {name} would be created at least twice after flatten_struct\"\n                    )\n                result_names[name] = col_expr\n                continue\n            if any(separator in (witness := field.name) for field in dtype.fields):\n                warnings.warn(\n                    f'separator \"{separator}\" found in field names, e.g. \"{witness}\" in {name}. '\n                    \"If columns would be repeated, this function will error\"\n                )\n            new_col_dtype_exprs += [\n                (\n                    field.dtype,\n                    col_expr.struct.field(field.name),\n                    name + separator + field.name,\n                )\n                for field in dtype.fields\n            ]\n            if not drop_original_struct:\n                ldf = ldf.with_columns(\n                    col_expr.struct.field(field.name).alias(\n                        name + separator + field.name\n                    )\n                    for field in dtype.fields\n                )\n        col_dtype_expr_names = new_col_dtype_exprs\n    if drop_original_struct and level == limit and col_dtype_expr_names:\n        for _, col_expr, name in col_dtype_expr_names:\n            result_names[name] = col_expr\n    if any((witness := column) in non_struct_columns for column in result_names):\n        raise ColumnNameRepeatedError(\n            f\"Column name {witness} would be created after flatten_struct, but it's already a non-struct column\"\n        )\n    if drop_original_struct:\n        ldf = ldf.select(\n            [col(c) for c in non_struct_columns]\n            + [col_expr.alias(name) for name, col_expr in result_names.items()]\n        )\n\n    if isinstance(df, LazyFrame):\n        return ldf\n    return ldf.collect()\n</code></pre>"},{"location":"reference/harley/#harley.is_null_or_blank","title":"<code>is_null_or_blank(expr, all_white_space_as_null=False)</code>","text":"<p>Returns True if null/blank/empty list. Otherwise, False.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_null_or_blank(expr: IntoExpr, all_white_space_as_null: bool = False) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if null/blank/empty list.\n    Otherwise, False.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_null_or_blank\",\n        is_elementwise=True,\n        lib=lib,\n        kwargs={\"all_white_space_as_null\": all_white_space_as_null},\n    )\n</code></pre>"},{"location":"reference/harley/#harley.print_schema_as_code","title":"<code>print_schema_as_code(schema, prepend_pl=False)</code>","text":"<p>Takes a schema as input and prints it as valid code, with an option to prepend 'pl.' to the column types.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OrderedDict[str, DataType]</code> <p>An OrderedDict where the keys are column names (strings) and the values are data types (DataType)</p> required <code>prepend_pl</code> <code>bool</code> <p>The <code>prepend_pl</code> parameter is a boolean flag that determines whether to prepend 'pl.' to the column types in the schema before printing it as code. If <code>prepend_pl</code> is set to True, each column type in the schema will be prefixed with 'pl.', defaults to False</p> <code>False</code> Source code in <code>harley/schema_helpers.py</code> <pre><code>def print_schema_as_code(\n    schema: OrderedDict[str, DataType], prepend_pl: bool = False\n) -&gt; None:\n    \"\"\"\n    Takes a schema as input and prints it as valid code, with an\n    option to prepend 'pl.' to the column types.\n\n    :param schema: An OrderedDict where the keys are column names (strings)\n    and the values are data types (DataType)\n    :type schema: OrderedDict[str, DataType]\n    :param prepend_pl: The `prepend_pl` parameter is a boolean flag that determines whether to prepend\n    'pl.' to the column types in the schema before printing it as code. If `prepend_pl` is set to True,\n    each column type in the schema will be prefixed with 'pl.', defaults to False\n    :type prepend_pl: bool (optional)\n    \"\"\"\n    if prepend_pl:\n        schema = OrderedDict(\n            [(field, \"pl.\" + str(d_type)) for field, d_type in schema.items()]\n        )\n    out = \"OrderedDict([\"\n    for name, d_type in schema.items():\n        out += '(\"' + name + '\", ' + str(d_type) + \"),\"\n    out += \"])\"\n    print(out)\n</code></pre>"},{"location":"reference/harley/#harley.remove_all_whitespace","title":"<code>remove_all_whitespace(expr)</code>","text":"<p>Removes all whitespace from a string.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def remove_all_whitespace(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Removes all whitespace from a string.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"remove_all_whitespace\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/#harley.remove_non_word_characters","title":"<code>remove_non_word_characters(expr)</code>","text":"<p>Removes all non-word characters. \"Word characters\" are [\\w\\s], i.e. alphanumeric, whitespace, and underscore (\"_\").</p> Source code in <code>harley/string_functions.py</code> <pre><code>def remove_non_word_characters(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Removes all non-word characters. \"Word characters\" are [\\w\\s], i.e. alphanumeric, whitespace, and underscore (\"_\").\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"remove_non_word_characters\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/#harley.single_space","title":"<code>single_space(expr)</code>","text":"<p>Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def single_space(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"single_space\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/#harley.snake_case_column_names","title":"<code>snake_case_column_names(df)</code>","text":"<p>Takes a PolarsFrame, converts its column names to snake case, and returns the modified PolarsFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame object, which can be eith er a LazyFrame or DataFrame.</p> required <p>Returns:</p> Type Description <code>PolarsFrame</code> <p>The function <code>snake_case_column_names</code> is returning a PolarsFrame with column names converted to snake case.</p> Source code in <code>harley/transformations.py</code> <pre><code>def snake_case_column_names(df: PolarsFrame) -&gt; PolarsFrame:\n    \"\"\"\n    Takes a PolarsFrame, converts its column names to snake case,\n    and returns the modified PolarsFrame.\n\n    :param df: A PolarsFrame object, which can be eith er a LazyFrame or DataFrame.\n    :type df: PolarsFrame\n    :return: The function `snake_case_column_names` is returning a PolarsFrame with column names\n    converted to snake case.\n    \"\"\"\n    if isinstance(df, LazyFrame):\n        all_column_names = df.collect_schema().names()\n    else:\n        all_column_names = df.columns\n    new_col_names = columns_to_snake_case(all_column_names)\n    return df.rename(new_col_names)\n</code></pre>"},{"location":"reference/harley/column_functions/","title":"column_functions","text":""},{"location":"reference/harley/column_functions/#harley.column_functions.approx_equal","title":"<code>approx_equal(col_1, col_2, threshold)</code>","text":"<p>Compares two columns for approximate equality within a specified threshold.</p> <p>Parameters:</p> Name Type Description Default <code>col_1</code> <code>IntoExpr</code> <p>The first column or expression that you want to compare for approximate equality</p> required <code>col_2</code> <code>IntoExpr</code> <p>The second column or value that you want to compare for approximate equality with col_1</p> required <code>threshold</code> <code>Union[float, int]</code> <p>Specifies the  maximum allowable difference between the values in <code>col_1</code> and <code>col_2</code> for them to be considered approximately equal.</p> required <p>Returns:</p> Type Description <code>IntoExpr</code> <p>boolean typed expression.</p> Source code in <code>harley/column_functions.py</code> <pre><code>def approx_equal(\n    col_1: IntoExpr, col_2: IntoExpr, threshold: Union[float, int]\n) -&gt; IntoExpr:\n    \"\"\"\n    Compares two columns for approximate equality within a specified threshold.\n\n    :param col_1: The first column or expression that you want to compare for approximate\n    equality\n    :type col_1: IntoExpr\n    :param col_2: The second column or value that you want to\n    compare for approximate equality with col_1\n    :type col_2: IntoExpr\n    :param threshold: Specifies the  maximum allowable difference between the values in `col_1` and `col_2` for them to be considered\n    approximately equal.\n    :type threshold: Union[float, int]\n    :return: boolean typed expression.\n    \"\"\"\n    col_1 = parse_into_expr(col_1)\n    col_2 = parse_into_expr(col_2)\n    return register_plugin(\n        args=[col_1, col_2],\n        symbol=\"approx_equal\",\n        is_elementwise=True,\n        lib=lib,\n        kwargs={\"threshold\": float(threshold)},\n    )\n</code></pre>"},{"location":"reference/harley/column_functions/#harley.column_functions.multi_equals","title":"<code>multi_equals(cols, val)</code>","text":"<p>Creates a query that checks if multiple columns have a specified value.</p> <p>Parameters:</p> Name Type Description Default <code>cols</code> <code>List[str]</code> <p>List[str]</p> required <code>val</code> <code>Any</code> <p>The value that you want to compare the columns against in the <code>multi_equals</code> function</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The function <code>multi_equals</code> returns an expression that represents the logical AND operation of equality checks between the columns specified in the <code>cols</code> list and the value <code>val</code>.</p> Source code in <code>harley/column_functions.py</code> <pre><code>def multi_equals(cols: List[str], val: Any) -&gt; Expr:\n    \"\"\"\n    Creates a query that checks if multiple columns have a specified value.\n\n    :param cols: List[str]\n    :type cols: List[str]\n    :param val: The value that you want to compare the columns against in the\n    `multi_equals` function\n    :type val: Any\n    :return: The function `multi_equals` returns an expression that represents the logical AND operation\n    of equality checks between the columns specified in the `cols` list and the value `val`.\n    \"\"\"\n    query = [pl.col(name) == val for name in cols]\n    return pl.all_horizontal(query)\n</code></pre>"},{"location":"reference/harley/column_functions/#harley.column_functions.null_between","title":"<code>null_between(col, lower, upper)</code>","text":"<p>The function <code>null_between</code> returns an expression to check if a column value falls within a range, handling null values appropriately.</p> <p>Parameters:</p> Name Type Description Default <code>col</code> <code>str</code> <p>The column for which you want to check if the values are null or fall within a certain range defined by the <code>lower</code> and <code>upper</code> bounds.</p> required <code>lower</code> <code>str</code> <p>The lower bound column or value that you want to compare against.</p> required <code>upper</code> <code>str</code> <p>The upper bound column or value that you want to compare against</p> required <p>Returns:</p> Type Description <code>Expr</code> <p>The <code>null_between</code> function is returning a polars expression that checks if a column <code>col</code> falls between two other columns <code>lower</code> and <code>upper</code>, handling cases where any of the columns are null.</p> Source code in <code>harley/column_functions.py</code> <pre><code>def null_between(col: str, lower: str, upper: str) -&gt; Expr:\n    \"\"\"\n    The function `null_between` returns an expression to check if a column value falls within a range,\n    handling null values appropriately.\n\n    :param col: The column for which you want to check if the values are\n    null or fall within a certain range defined by the `lower` and `upper` bounds.\n    :type col: str\n    :param lower: The lower bound column or value that you want to compare against.\n    :type lower: str\n    :param upper: The upper bound column or value that you want to compare against\n    :type upper: str\n    :return: The `null_between` function is returning a polars expression that checks if a column\n    `col` falls between two other columns `lower` and `upper`, handling cases where any of the columns\n    are null.\n    \"\"\"\n    return (\n        pl.when(pl.col(lower).is_null() &amp; pl.col(upper).is_null())\n        .then(False)\n        .when(pl.col(col).is_null())\n        .then(False)\n        .when(pl.col(lower).is_null())\n        .then(pl.col(col) &lt;= pl.col(upper))\n        .when(pl.col(upper).is_null())\n        .then(pl.col(col) &gt;= pl.col(lower))\n        .otherwise(pl.col(col).is_between(pl.col(lower), pl.col(upper)))\n    )\n</code></pre>"},{"location":"reference/harley/dataframe_helper/","title":"dataframe_helper","text":""},{"location":"reference/harley/dataframe_helper/#harley.dataframe_helper.column_to_list","title":"<code>column_to_list(df, column)</code>","text":"<p>Takes a PolarsFrame and a column name, extracts the specified column as a list, and returns it.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>PolarsFrame</p> required <code>column</code> <code>str</code> <p>The name of the column in the Polars DataFrame (<code>df</code>) that you want to extract and convert into a Python list</p> required <p>Returns:</p> Type Description <code>List</code> <p>a list of values from the specified column in the PolarsFrame dataframe.</p> Source code in <code>harley/dataframe_helper.py</code> <pre><code>def column_to_list(df: PolarsFrame, column: str) -&gt; List:\n    \"\"\"\n    Takes a PolarsFrame and a column name, extracts the specified column as a list, and\n    returns it.\n\n    :param df: PolarsFrame\n    :type df: PolarsFrame\n    :param column: The name of the column in\n    the Polars DataFrame (`df`) that you want to extract and convert into a Python list\n    :type column: str\n    :return: a list of values from the specified column in the PolarsFrame dataframe.\n    \"\"\"\n    if isinstance(df := df.select(column), LazyFrame):\n        df = df.collect()\n    series = df.select(column).to_series()\n    return series.to_list()\n</code></pre>"},{"location":"reference/harley/dataframe_helper/#harley.dataframe_helper.two_columns_to_dictionary","title":"<code>two_columns_to_dictionary(df, key_col_name, value_col_name, allow_duplicates_keys=False)</code>","text":"<p>Converts two columns from a DataFrame into a dictionary, with one column as keys and the other as values, handling potential issues like duplicate keys and non-hashable types.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>A DataFrame containing the data you want to convert into a dictionary</p> required <code>key_col_name</code> <code>str</code> <p>The name of the column in the DataFrame that will be used as the key in the resulting dictionary. This column should contain unique values that will serve as the keys in the dictionary mapping.</p> required <code>value_col_name</code> <code>str</code> <p>The name of the column in the DataFrame that contains the values you want to map to the keys in the dictionary.</p> required <code>allow_duplicates_keys</code> <code>bool</code> <p>A boolean flag that determines whether duplicate keys are allowed in the resulting dictionary. If set to <code>False</code> (default), the function will raise a <code>ValueError</code> if duplicate keys are found in the specified key column, defaults to False</p> <code>False</code> <p>Returns:</p> Type Description <code>Dict[Any, Any]</code> <p>Converts the two specified columns from the DataFrame into a dictionary where the key is the value from the key column and the value is the value from the value column.</p> Source code in <code>harley/dataframe_helper.py</code> <pre><code>def two_columns_to_dictionary(\n    df: DataFrame,\n    key_col_name: str,\n    value_col_name: str,\n    allow_duplicates_keys: bool = False,\n) -&gt; Dict[Any, Any]:\n    \"\"\"\n    Converts two columns from a DataFrame into a dictionary,\n    with one column as keys and the other as values,\n    handling potential issues like duplicate keys and\n    non-hashable types.\n\n    :param df: A DataFrame containing the data you want to convert into a dictionary\n    :type df: DataFrame\n    :param key_col_name: The name of the column in the DataFrame that will be used as the key in the resulting dictionary.\n    This column should contain unique values that will serve as the keys in the dictionary mapping.\n    :type key_col_name: str\n    :param value_col_name: The name of the column in the DataFrame that contains the\n    values you want to map to the keys in the dictionary.\n    :type value_col_name: str\n    :param allow_duplicates_keys: A boolean flag that determines whether duplicate keys are\n    allowed in the resulting dictionary. If set to `False` (default), the function will raise a\n    `ValueError` if duplicate keys are found in the specified key column, defaults to False\n    :type allow_duplicates_keys: bool (optional)\n    :return: Converts the two specified columns from the DataFrame into a dictionary\n    where the key is the value from the key column and the value is the value from the value column.\n    \"\"\"\n    df = df.select(key_col_name, value_col_name)\n    key_dtype = df.dtypes[0]\n    if key_dtype.is_nested():\n        raise ValueError(\n            f\"Column {key_col_name} is of type {df.dtypes[0]} will not return a hashable type.\",\n            f\"Therefore {key_col_name} cannot provide an acceptable key\",\n        )\n    if key_dtype in [Object, Unknown]:\n        raise ValueError(\n            f\"Column {key_col_name} is of type {df.dtypes[0]} and may not return a hashable type.\",\n            f\"Therefore {key_col_name} cannot provide an acceptable key.\",\n        )\n    if not allow_duplicates_keys:\n        if df.filter(col(key_col_name).is_duplicated()).height &gt; 0:\n            raise ValueError(\n                \"Duplicate records found in key column.\",\n                \"Duplicate keys will be overwritten and de-duplicated unpredicatbly.\",\n                \"To allow duplicate keys, set `allow_duplicate_keys` to True\",\n                \"Some of the duplicates:\",\n                column_to_list(\n                    df.filter((col(key_col_name).is_duplicated())), key_col_name\n                )[:3],\n            )\n    df = df.to_dicts()\n    return {row[key_col_name]: row[value_col_name] for row in df}\n</code></pre>"},{"location":"reference/harley/dataframe_validator/","title":"dataframe_validator","text":""},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.DataFrameMissingColumnError","title":"<code>DataFrameMissingColumnError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raise this when there's a DataFrame column error.</p> Source code in <code>harley/dataframe_validator.py</code> <pre><code>class DataFrameMissingColumnError(ValueError):\n    \"\"\"Raise this when there's a DataFrame column error.\"\"\"\n</code></pre>"},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.DataFrameProhibitedColumnError","title":"<code>DataFrameProhibitedColumnError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raise this when a DataFrame includes prohibited columns.</p> Source code in <code>harley/dataframe_validator.py</code> <pre><code>class DataFrameProhibitedColumnError(ValueError):\n    \"\"\"Raise this when a DataFrame includes prohibited columns.\"\"\"\n</code></pre>"},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.DataSchemaError","title":"<code>DataSchemaError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>Raise this when schema validation fails</p> Source code in <code>harley/dataframe_validator.py</code> <pre><code>class DataSchemaError(ValueError):\n    \"\"\"Raise this when schema validation fails\"\"\"\n</code></pre>"},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.validate_absence_of_columns","title":"<code>validate_absence_of_columns(df, prohibited_col_names)</code>","text":"<p>Checks for the presence of prohibited columns in a DataFrame and raises an error if any are found.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame object representing a DataFrame or LazyFrame</p> required <code>prohibited_col_names</code> <code>List[str]</code> <p>A list of column names that should not be present in the DataFrame <code>df</code>. The function <code>validate_absence_of_columns</code> checks if Raises a <code>DataFrameProhibitedColumnError</code> if any of the columns are present.</p> required Source code in <code>harley/dataframe_validator.py</code> <pre><code>def validate_absence_of_columns(\n    df: PolarsFrame, prohibited_col_names: List[str]\n) -&gt; None:\n    \"\"\"\n    Checks for the presence of prohibited columns in a DataFrame and raises an error if any are found.\n\n    :param df: A PolarsFrame object representing a DataFrame or LazyFrame\n    :type df: PolarsFrame\n    :param prohibited_col_names: A list of column names that should not be present in the DataFrame `df`. The function `validate_absence_of_columns` checks if\n    Raises a `DataFrameProhibitedColumnError` if any of the columns are present.\n    :type prohibited_col_names: List[str]\n    \"\"\"\n    if isinstance(df, LazyFrame):\n        df_cols = df.collect_schema().names()\n    else:\n        df_cols = df.columns\n    present_prohibited_col_names = [\n        col for col in prohibited_col_names if col in df_cols\n    ]\n    if present_prohibited_col_names:\n        raise DataFrameProhibitedColumnError(\n            \"Prohibited columns present:\", present_prohibited_col_names\n        )\n</code></pre>"},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.validate_presence_of_columns","title":"<code>validate_presence_of_columns(df, required_col_names)</code>","text":"<p>Validate the presence of column names in a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A spark DataFrame.</p> required <code>required_col_names</code> <code>List[str]</code> <p>List of the required column names for the DataFrame.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None.</p> <p>Raises:</p> Type Description <code>DataFrameMissingColumnError</code> <p>if any of the requested column names are not present in the DataFrame.</p> Source code in <code>harley/dataframe_validator.py</code> <pre><code>def validate_presence_of_columns(\n    df: PolarsFrame, required_col_names: List[str]\n) -&gt; None:\n    \"\"\"Validate the presence of column names in a DataFrame.\n\n    :param df: A spark DataFrame.\n    :type df: DataFrame`\n    :param required_col_names: List of the required column names for the DataFrame.\n    :type required_col_names: :py:class:`list` of :py:class:`str`\n    :return: None.\n    :raises DataFrameMissingColumnError: if any of the requested column names are\n    not present in the DataFrame.\n    \"\"\"\n    if isinstance(df, LazyFrame):\n        all_col_names = df.collect_schema().names()\n    else:\n        all_col_names = df.columns\n    missing_col_names = [x for x in required_col_names if x not in all_col_names]\n    error_message = f\"The {missing_col_names} columns are not included in the DataFrame with the following columns {all_col_names}\"\n    if missing_col_names:\n        raise DataFrameMissingColumnError(error_message)\n</code></pre>"},{"location":"reference/harley/dataframe_validator/#harley.dataframe_validator.validate_schema","title":"<code>validate_schema(df, required_schema)</code>","text":"<p>Validates whether a given DataFrame matches an expected schema.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame object representing a DataFrame or a LazyFrame</p> required <code>required_schema</code> <code>Union[Dict, OrderedDict]</code> <p>The <code>required_schema</code> parameter is a dictionary or an ordered dictionary that represents the schema that the input <code>df</code> (PolarsFrame) should adhere to. The function <code>validate_schema</code> compares the schema of the input dataframe with the required schema and raises a <code>DataSchemaError</code> if they do not match.</p> required Source code in <code>harley/dataframe_validator.py</code> <pre><code>def validate_schema(df: PolarsFrame, required_schema: Union[Dict, OrderedDict]) -&gt; None:\n    \"\"\"\n    Validates whether a given DataFrame matches an expected schema.\n\n    :param df: A PolarsFrame object representing a DataFrame or a LazyFrame\n    :type df: PolarsFrame\n    :param required_schema: The `required_schema` parameter is a dictionary or an ordered dictionary\n    that represents the schema that the input `df` (PolarsFrame) should adhere to. The function\n    `validate_schema` compares the schema of the input dataframe with the required schema and raises a\n    `DataSchemaError` if they do not match.\n    :type required_schema: Union[Dict, OrderedDict]\n    \"\"\"\n    if isinstance(df, LazyFrame):\n        df_schema = df.collect_schema()\n    else:\n        df_schema = df.schema\n    if isinstance(required_schema, dict):\n        df_schema = dict(df_schema)\n    if not required_schema == df_schema:\n        raise DataSchemaError(\"The Frame did not match the expected schema\")\n</code></pre>"},{"location":"reference/harley/maths/","title":"maths","text":""},{"location":"reference/harley/maths/#harley.maths.div_or_else","title":"<code>div_or_else(dividend, divisor, or_else=0.0)</code>","text":"<p>Returns the result of dividing one expression by another, with an optional default value if the divisor is zero.</p> <p>Parameters:</p> Name Type Description Default <code>dividend</code> <code>IntoExpr</code> <p>The value that will be divided</p> required <code>divisor</code> <code>IntoExpr</code> <p>The value by which the <code>dividend</code> will be divided. If the <code>divisor</code> is zero, the function will return the <code>or_else</code> value instead of performing the division</p> required <code>or_else</code> <code>Union[int, float]</code> <p>TA default value that will be returned if the divisor is zero. It is a numeric value (either an integer or a float) and is set to 0.0 by default if not provided explicitly.</p> <code>0.0</code> <p>Returns:</p> Type Description <code>IntoExpr</code> <p>The result of the division of <code>dividend</code> by <code>divisor</code>, or the default value <code>or_else</code> if the divisor is zero.</p> Source code in <code>harley/maths.py</code> <pre><code>def div_or_else(\n    dividend: IntoExpr, divisor: IntoExpr, or_else: Union[int, float] = 0.0\n) -&gt; IntoExpr:\n    \"\"\"\n    Returns the result of dividing one expression by another, with an optional default\n    value if the divisor is zero.\n\n    :param dividend: The value that will be divided\n    :type dividend: IntoExpr\n    :param divisor: The value by which\n    the `dividend` will be divided. If the `divisor` is zero, the function will return the `or_else`\n    value instead of performing the division\n    :type divisor: IntoExpr\n    :param or_else: TA default value that will\n    be returned if the divisor is zero. It is a numeric value (either an integer or a float) and is set\n    to 0.0 by default if not provided explicitly.\n    :type or_else: Union[int, float]\n    :return: The result of the division of `dividend` by `divisor`,\n    or the default value `or_else` if the divisor is zero.\n    \"\"\"\n    dividend = parse_into_expr(dividend)\n    divisor = parse_into_expr(divisor)\n    return register_plugin(\n        args=[dividend, divisor],\n        symbol=\"div_or_else\",\n        is_elementwise=True,\n        kwargs={\"or_else\": float(or_else)},\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/schema_helpers/","title":"schema_helpers","text":""},{"location":"reference/harley/schema_helpers/#harley.schema_helpers.print_schema_as_code","title":"<code>print_schema_as_code(schema, prepend_pl=False)</code>","text":"<p>Takes a schema as input and prints it as valid code, with an option to prepend 'pl.' to the column types.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>OrderedDict[str, DataType]</code> <p>An OrderedDict where the keys are column names (strings) and the values are data types (DataType)</p> required <code>prepend_pl</code> <code>bool</code> <p>The <code>prepend_pl</code> parameter is a boolean flag that determines whether to prepend 'pl.' to the column types in the schema before printing it as code. If <code>prepend_pl</code> is set to True, each column type in the schema will be prefixed with 'pl.', defaults to False</p> <code>False</code> Source code in <code>harley/schema_helpers.py</code> <pre><code>def print_schema_as_code(\n    schema: OrderedDict[str, DataType], prepend_pl: bool = False\n) -&gt; None:\n    \"\"\"\n    Takes a schema as input and prints it as valid code, with an\n    option to prepend 'pl.' to the column types.\n\n    :param schema: An OrderedDict where the keys are column names (strings)\n    and the values are data types (DataType)\n    :type schema: OrderedDict[str, DataType]\n    :param prepend_pl: The `prepend_pl` parameter is a boolean flag that determines whether to prepend\n    'pl.' to the column types in the schema before printing it as code. If `prepend_pl` is set to True,\n    each column type in the schema will be prefixed with 'pl.', defaults to False\n    :type prepend_pl: bool (optional)\n    \"\"\"\n    if prepend_pl:\n        schema = OrderedDict(\n            [(field, \"pl.\" + str(d_type)) for field, d_type in schema.items()]\n        )\n    out = \"OrderedDict([\"\n    for name, d_type in schema.items():\n        out += '(\"' + name + '\", ' + str(d_type) + \"),\"\n    out += \"])\"\n    print(out)\n</code></pre>"},{"location":"reference/harley/string_functions/","title":"string_functions","text":""},{"location":"reference/harley/string_functions/#harley.string_functions.anti_trim","title":"<code>anti_trim(expr)</code>","text":"<p>Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def anti_trim(expr: List[IntoExpr]) -&gt; IntoExpr:\n    \"\"\"\n    Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"anti_trim\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/string_functions/#harley.string_functions.remove_all_whitespace","title":"<code>remove_all_whitespace(expr)</code>","text":"<p>Removes all whitespace from a string.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def remove_all_whitespace(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Removes all whitespace from a string.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"remove_all_whitespace\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/string_functions/#harley.string_functions.remove_non_word_characters","title":"<code>remove_non_word_characters(expr)</code>","text":"<p>Removes all non-word characters. \"Word characters\" are [\\w\\s], i.e. alphanumeric, whitespace, and underscore (\"_\").</p> Source code in <code>harley/string_functions.py</code> <pre><code>def remove_non_word_characters(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Removes all non-word characters. \"Word characters\" are [\\w\\s], i.e. alphanumeric, whitespace, and underscore (\"_\").\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"remove_non_word_characters\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/string_functions/#harley.string_functions.single_space","title":"<code>single_space(expr)</code>","text":"<p>Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.</p> Source code in <code>harley/string_functions.py</code> <pre><code>def single_space(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Replaces all whitespace to a single space from a string, then trims leading and trailing spaces.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"single_space\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/to_boolean/","title":"to_boolean","text":""},{"location":"reference/harley/to_boolean/#harley.to_boolean.is_false","title":"<code>is_false(expr)</code>","text":"<p>Returns True if False, otherwise False. Whitespace aware.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_false(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if False, otherwise False.\n    Whitespace aware.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_false\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/to_boolean/#harley.to_boolean.is_falsey","title":"<code>is_falsey(expr)</code>","text":"<p>Returns True if null/False, otherwise False.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_falsey(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if null/False, otherwise False.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_falsey\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/to_boolean/#harley.to_boolean.is_null_or_blank","title":"<code>is_null_or_blank(expr, all_white_space_as_null=False)</code>","text":"<p>Returns True if null/blank/empty list. Otherwise, False.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_null_or_blank(expr: IntoExpr, all_white_space_as_null: bool = False) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if null/blank/empty list.\n    Otherwise, False.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_null_or_blank\",\n        is_elementwise=True,\n        lib=lib,\n        kwargs={\"all_white_space_as_null\": all_white_space_as_null},\n    )\n</code></pre>"},{"location":"reference/harley/to_boolean/#harley.to_boolean.is_true","title":"<code>is_true(expr)</code>","text":"<p>Returns True if True, otherwise False. Whitespace aware.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_true(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if True, otherwise False.\n    Whitespace aware.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_true\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/to_boolean/#harley.to_boolean.is_truthy","title":"<code>is_truthy(expr)</code>","text":"<p>Returns True if True, otherwise False. Whitespace aware.</p> Source code in <code>harley/to_boolean.py</code> <pre><code>def is_truthy(expr: IntoExpr) -&gt; IntoExpr:\n    \"\"\"\n    Returns True if True, otherwise False.\n    Whitespace aware.\n    \"\"\"\n    expr = parse_into_expr(expr)\n    return register_plugin(\n        args=[expr],\n        symbol=\"is_truthy\",\n        is_elementwise=True,\n        lib=lib,\n    )\n</code></pre>"},{"location":"reference/harley/transformations/","title":"transformations","text":""},{"location":"reference/harley/transformations/#harley.transformations.ColumnNameRepeatedError","title":"<code>ColumnNameRepeatedError</code>","text":"<p>               Bases: <code>ValueError</code></p> <p>raised when a column name would be repeated after flatten_struct</p> Source code in <code>harley/transformations.py</code> <pre><code>class ColumnNameRepeatedError(ValueError):\n    \"\"\"raised when a column name would be repeated after flatten_struct\"\"\"\n</code></pre>"},{"location":"reference/harley/transformations/#harley.transformations.flatten_struct","title":"<code>flatten_struct(df, struct_columns, separator=':', drop_original_struct=True, recursive=False, limit=None)</code>","text":"<p>Takes a PolarsFrame and flattens specified struct columns into separate columns using a specified separator, with options to control recursion and limit the number of flattening levels.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame, either a LazyFrame or DataFrame.</p> required <code>struct_columns</code> <code>Union[str, List[str]]</code> <p>The column or columns in the PolarsFrame that contain struct data. This function is designed to flatten the struct data into separate columns based on the fields within the struct.</p> required <code>separator</code> <code>str</code> <p>Specifies the character or string that will be used to separate the original column name from the nested field names when flattening a nested struct column.</p> <code>':'</code> <code>drop_original_struct</code> <code>bool</code> <p>Determines whether the original struct columns should be dropped after flattening or not, defaults to True.</p> <code>True</code> <code>recursive</code> <code>bool</code> <p>Determines whether the flattening process should be applied recursively to all levels of nested structures within the specified struct columns, defaults to False.</p> <code>False</code> <code>limit</code> <code>int</code> <p>Determines the maximum number of levels to flatten the struct columns. If <code>limit</code> is set to a positive integer, the function will flatten the struct columns up to that specified level. If <code>limit</code> is set to <code>None</code>, there is no limit.</p> <code>None</code> <p>Returns:</p> Type Description <code>PolarsFrame</code> <p>returns a PolarsFrame.</p> Source code in <code>harley/transformations.py</code> <pre><code>def flatten_struct(\n    df: PolarsFrame,\n    struct_columns: Union[str, List[str]],\n    separator: str = \":\",\n    drop_original_struct: bool = True,\n    recursive: bool = False,\n    limit: int = None,\n) -&gt; PolarsFrame:\n    \"\"\"\n    Takes a PolarsFrame and flattens specified struct columns into\n    separate columns using a specified separator,\n    with options to control recursion and limit the number\n    of flattening levels.\n\n    :param df: A PolarsFrame, either a LazyFrame or DataFrame.\n    :type df: PolarsFrame\n    :param struct_columns: The column or columns in the PolarsFrame that contain struct data.\n    This function is designed to flatten the struct data into separate columns based on the fields within the struct.\n    :type struct_columns: Union[str, List[str]]\n    :param separator: Specifies the character or string that will be used to separate the original\n    column name from the nested field names when flattening a nested struct column.\n    :type separator: str (optional)\n    :param drop_original_struct: Determines whether the original struct columns should be dropped after flattening or not,\n    defaults to True.\n    :type drop_original_struct: bool (optional)\n    :param recursive: Determines whether the flattening process should be applied recursively to\n    all levels of nested structures within the specified struct columns, defaults to False.\n    :type recursive: bool (optional)\n    :param limit: Determines the maximum number of levels to flatten the struct columns.\n    If `limit` is set to a positive integer, the function will flatten the struct columns up to that specified level.\n    If `limit` is set to `None`, there is no limit.\n    :type limit: int\n    :return: returns a PolarsFrame.\n    \"\"\"\n    if isinstance(struct_columns, str):\n        struct_columns = [struct_columns]\n    if not recursive:\n        limit = 1\n    if limit is not None and not isinstance(limit, int):\n        raise ValueError(\"limit must be a positive integer or None\")\n    if limit is not None and limit &lt; 0:\n        raise ValueError(\"limit must be a positive integer or None\")\n    if limit == 0:\n        warnings.warn(\"limit of 0 will result in no transformations\")\n        return df\n    ldf = df.lazy()  # noop if df is LazyFrame\n    all_column_names = ldf.collect_schema().names()\n    if any(separator in (witness := column) for column in all_column_names):\n        warnings.warn(\n            f'separator \"{separator}\" found in column names, e.g. \"{witness}\". '\n            \"If columns would be repeated, this function will error\"\n        )\n    non_struct_columns = list(set(ldf.collect_schema().names()) - set(struct_columns))\n    struct_schema = ldf.select(*struct_columns).collect_schema()\n    col_dtype_expr_names = [(struct_schema[c], col(c), c) for c in struct_columns]\n    result_names: Dict[str, Expr] = {}\n    level = 0\n    while (limit is None and col_dtype_expr_names) or (\n        limit is not None and level &lt; limit\n    ):\n        level += 1\n        new_col_dtype_exprs = []\n        for dtype, col_expr, name in col_dtype_expr_names:\n            if not isinstance(dtype, Struct):\n                if name in result_names:\n                    raise ColumnNameRepeatedError(\n                        f\"Column name {name} would be created at least twice after flatten_struct\"\n                    )\n                result_names[name] = col_expr\n                continue\n            if any(separator in (witness := field.name) for field in dtype.fields):\n                warnings.warn(\n                    f'separator \"{separator}\" found in field names, e.g. \"{witness}\" in {name}. '\n                    \"If columns would be repeated, this function will error\"\n                )\n            new_col_dtype_exprs += [\n                (\n                    field.dtype,\n                    col_expr.struct.field(field.name),\n                    name + separator + field.name,\n                )\n                for field in dtype.fields\n            ]\n            if not drop_original_struct:\n                ldf = ldf.with_columns(\n                    col_expr.struct.field(field.name).alias(\n                        name + separator + field.name\n                    )\n                    for field in dtype.fields\n                )\n        col_dtype_expr_names = new_col_dtype_exprs\n    if drop_original_struct and level == limit and col_dtype_expr_names:\n        for _, col_expr, name in col_dtype_expr_names:\n            result_names[name] = col_expr\n    if any((witness := column) in non_struct_columns for column in result_names):\n        raise ColumnNameRepeatedError(\n            f\"Column name {witness} would be created after flatten_struct, but it's already a non-struct column\"\n        )\n    if drop_original_struct:\n        ldf = ldf.select(\n            [col(c) for c in non_struct_columns]\n            + [col_expr.alias(name) for name, col_expr in result_names.items()]\n        )\n\n    if isinstance(df, LazyFrame):\n        return ldf\n    return ldf.collect()\n</code></pre>"},{"location":"reference/harley/transformations/#harley.transformations.snake_case_column_names","title":"<code>snake_case_column_names(df)</code>","text":"<p>Takes a PolarsFrame, converts its column names to snake case, and returns the modified PolarsFrame.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>PolarsFrame</code> <p>A PolarsFrame object, which can be eith er a LazyFrame or DataFrame.</p> required <p>Returns:</p> Type Description <code>PolarsFrame</code> <p>The function <code>snake_case_column_names</code> is returning a PolarsFrame with column names converted to snake case.</p> Source code in <code>harley/transformations.py</code> <pre><code>def snake_case_column_names(df: PolarsFrame) -&gt; PolarsFrame:\n    \"\"\"\n    Takes a PolarsFrame, converts its column names to snake case,\n    and returns the modified PolarsFrame.\n\n    :param df: A PolarsFrame object, which can be eith er a LazyFrame or DataFrame.\n    :type df: PolarsFrame\n    :return: The function `snake_case_column_names` is returning a PolarsFrame with column names\n    converted to snake case.\n    \"\"\"\n    if isinstance(df, LazyFrame):\n        all_column_names = df.collect_schema().names()\n    else:\n        all_column_names = df.columns\n    new_col_names = columns_to_snake_case(all_column_names)\n    return df.rename(new_col_names)\n</code></pre>"}]}